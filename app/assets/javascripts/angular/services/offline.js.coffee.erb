getData = (resource) ->
  data = {}
  for own key, val of resource
    if key[0] != '$' && # angular variable
       key[0] != '_'    # our own internal variable
      if typeof(val) == 'object'
        data[key] = angular.copy(val)
      else
        data[key] = val
  return data

# Checks if a mobile device has a connection (always true on desktop)
online = ->
  connection_type = navigator.network?.connection?.type
  if connection_type?
    return connection_type != Connection?.NONE
  return navigator.onLine

# By default, just try to match all given keys exactly.
defaultMatch = (params, data) ->
  for key, val of params
    if val instanceof RegExp
      if !data[key]?.match?(val)?
        return false
    else if !angular.equals(data[key], val)
      return false
  return true

syncCollection = (dest, newData, last_synced) ->
  return if !(newData instanceof Array)

  destMap = {}
  destMap[val.id] = val for val in dest
  existingMap = {}
  existingMap[val.id] = val for val in dest

  updated = false
  result = []
  for val in dest
    if !existingMap[val.id] && val.created_at < last_synced
      # must have been deleted locally.
      updated = true
    else if existingMap[val.id]
      updated ||= syncFields(val, existingMap[val.id])
      result.push(val)
    else
      result.push(val)

  for val in newData
    if !destMap[val.id] && val.created_at > last_synced
      updated = true
      result.push(val)

  result.sort((a, b) -> (a.id || '').localeCompare(b.id || ''))
  angular.copy(result, dest)
  return updated

# By default, assume every field has a 'value' and 'updated_at'. Sync based on the latest
syncFields = (dest, newData, last_synced, overwrite) ->
  updated = false
  # Check each field individually, and update
  for key, val of newData
    if val.updated_at?
      if (dest[key]?.value instanceof Array) && dest[key].value[0]?.id? # supports deep merging?
        if !dest[key].updated_at? || val.updated_at > dest[key].updated_at
          dest[key].updated_at = val.updated_at
        updated ||= syncCollection(dest[key].value, val.value, last_synced)
      else if !dest[key]?.updated_at? || dest[key].updated_at < val.updated_at
        dest[key] = val
        updated = true

  if newData.updated_at > dest.updated_at
    dest.updated_at = newData.updated_at

  return updated

markCollectionChanges = (newData, oldData) ->
    updated = (newData.length != oldData.length)
    oldIDs = {}
    oldIDs[val.id] = val for val in oldData
    for val in newData
      if old = oldIDs[val.id]
        updated ||= markChanges(val, old)
      else
        val.created_at = val.updated_at = Date.now()
        updated = true
    return updated

markChanges = (newData, oldData) ->
  updated = false

  for key, val of newData
    valUpdated = false
    newVal = val?.value
    oldVal = oldData?[key]?.value
    if (newVal instanceof Array) && (oldVal instanceof Array)
      valUpdated = markCollectionChanges(newVal, oldVal)
    else
      valUpdated = !angular.equals(newVal, oldVal)
    if valUpdated
      val.updated_at = Date.now()
      val.created_at ||= val.updated_at
    updated ||= valUpdated

  for key, val of oldData
    if val? && !newData[key]?
      updated = true

  if updated
    newData.updated_at = Date.now()
    newData.created_at ||= newData.updated_at

  return updated

# Wraps the localstorage class.
class LocalStorage
  constructor: (@AuthToken, @key, @sync_fn) ->
    @obj_last_synced = {}

  storageKey: ->
    @AuthToken.get().email + ':' + @key

  getDB: ->
    try
      return angular.fromJson(window.localStorage.getItem(@storageKey()))
    catch err
      return {}

  saveDB: (db) ->
    window.localStorage.setItem(@storageKey(), angular.toJson(db))

  getLastSynced: (obj) ->
    return (obj? && @obj_last_synced[obj]) ||
      +window.localStorage.getItem(@storageKey() + '.lastSynced') || 0

  setLastSynced: (time, obj) ->
    if obj?
      @obj_last_synced[obj] = time
    else
      window.localStorage.setItem(@storageKey() + '.lastSynced', time)  

  update: (resource, overwrite = false) ->
    data = getData(resource)

    db = @getDB() || {}
    need_update = false
    existing = db[data.id]
    if !overwrite && existing
      if !existing.id? # deleted
        return existing
      need_update = @sync_fn(data, existing, @getLastSynced(data.id))
    else
      markChanges(data, existing)
      angular.extend(resource, data)

    db[data.id] = data
    @saveDB(db)
    return if need_update then data else null

  delete: (id, permanent = false) ->
    db = @getDB() || {}
    if permanent
      delete db[id]
    else
      # Mark for deletion. Can't actually delete, or we won't be able to sync it
      db[id].id = null
      db[id].updated_at = Date.now()
    @saveDB(db)

  get: (id) ->
    @getDB()?[id]

  getAll: ->
    @getDB()? && (key for val, key of @getDB())

# Wraps an angular HTTP resource with offline functionality.
App.factory 'Offline', ['$resource', '$timeout', 'AuthToken', ($resource, $timeout, AuthToken) -> {
  online: online,

  sync: (offlineClasses, success, error) ->
    remaining = offlineClasses.length
    successful = true
    finalize = ->
      if successful
        success() if success
      else
        error() if error

    for cls in offlineClasses
      cls.sync(
        (->
          remaining -= 1
          if remaining == 0
            finalize()),
        (->
          remaining -= 1
          successful = false
          if remaining == 0
            finalize()))

  # key - index to use for local storage DB
  # resource_url - HTTP resource URL
  # match_fn - select function (for query/get)
  wrap: (key, resource_url, match_fn = defaultMatch, sync_fn = syncFields) ->
    resource = $resource(resource_url, {format: 'json', id: '@id'}, {
      'save': {method: 'PUT'},
      'create': {method: 'POST'}
    })
    storage = new LocalStorage(AuthToken, key, sync_fn)
    class OfflineResource
      constructor: (data = {}) ->
        rsrc = new resource(data)
        angular.extend(this, rsrc)

        timestamp = Date.now()
        @created_at ||= timestamp
        @updated_at ||= timestamp

        # Generate a nearly guaranteed unique id.
        @generateId() if !@id
        @_save = rsrc.$save.bind(this)
        @_create = rsrc.$create.bind(this)
        @_delete = rsrc.$delete.bind(this)

      generateId: ->
        @id = generateGUID()
        @_isNew = true

      getData: ->
        getData(this)

      isNew: ->
        @_isNew || @created_at > storage.getLastSynced(@id)

      $save: (success, error) ->
        storage.update(this, true)

        if online()
          save_fn = if @isNew() then @_create else @_save
          save_fn(AuthToken.addAuthTokenToJSONRequest({last_synced: storage.getLastSynced(@id)}), (data) =>
            # Delete the temporary model from the local DB if it exists.
            angular.extend(this, storage.update(data) || getData(data))
            storage.setLastSynced(Date.now(), @id)
            @_isNew = false
            success(this) if success
          , (data) =>
              if data.status == 410 # GONE; deleted from the server
                storage.delete(@id, true)
              else if data.status == 422 # Validation failed for some reason. Don't save
              else # can't reach the server, we'll just leave it as is
                storage.update(this)
                OfflineResource.defer(=> success(this)) if success
                return
              OfflineResource.defer(=> error(data)) if error
          )
        else
          success(this) if success

      $delete: ->
        storage.delete(@id)
        @_delete(AuthToken.addAuthTokenToJSONRequest({}), (data) =>
          storage.delete(@id, true)) if online()

      # Ensures a function is called after the current method returns.
      @defer: (fn) ->
        $timeout(fn, 0)

      @synced_recently: ->
        # Synced in the last 10 seconds
        Date.now() - storage.getLastSynced() < 10

      @syncObject: (data) ->
        updated = storage.update(data)
        if updated?
          if updated.id != null
            angular.extend(data, updated)
            # Let the server possibly merge again.
            # (e.g. to update the timestamps properly)
            offline = new OfflineResource(updated)
            data.$save((data2) ->
              storage.update(data2, true)
              angular.extend(offline, data2)
              storage.setLastSynced(Date.now(), data.id)
            ) if online()
          else
            data.$delete(-> storage.delete(id, true)) if online()
            return null
        else
          storage.setLastSynced(Date.now(), data.id)
          offline = new OfflineResource(getData(data))
        return offline

      @sync: (success, error) ->
        # Super simple sync function that checks everything. Can easily be made more efficient
        if online()
          last_sync = storage.getLastSynced()
          resource.query(AuthToken.addAuthTokenToJSONRequest({last_synced: last_sync}), (data) =>
            for item in data
              if item.deleted
                storage.delete(item.id, true)
              else
                @syncObject(item)

            for id, val of storage.getDB()
              if !val.id?
                offline = new OfflineResource(val)
                offline.id = id
                offline.$delete(-> storage.delete(id, true))
              else if val.created_at > last_sync
                offline = new OfflineResource(val)
                offline.$save()

            storage.setLastSynced(Date.now())
            success(data) if success
          , error || angular.noop)
        else
          @defer(error) if error

      @get: (params, success, error) ->
        res = new OfflineResource(params)
        res.IS_NEW = false

        queryLocal = (data) =>
          if params.id
            ret = storage.get(params.id)
            if ret?.id?
              angular.extend(res, ret)
              @defer(=> success(res)) if success
            else
              @defer(=> error(data)) if error
          else if match_fn
            for val in storage.getAll()
              if val.id? && match_fn(params, val)
                angular.extend(res, val)
                @defer(=> success(res)) if success
                return
            @defer(=> error(data)) if error

        if online() && !@synced_recently()
          resource.get(AuthToken.addAuthTokenToJSONRequest(params),
            (data) =>
              @syncObject(data)
              queryLocal()
          , (data) =>
              if data.status == 410 # GONE; this means it was deleted
                res.id = null
                storage.delete(params.id, true)
                @defer(=> error(data)) if error
              else # the server is unreachable; use the cache
                queryLocal()
          )
        else
          queryLocal()

        return res

      @query: (params, success, error) ->
        res = []
        queryLocal = (data) =>
          stored = storage.getAll()
          if stored != false
            start = params.start || 0
            limit = params.limit || 1e9
            desc = if params.desc then -1 else 1
            stored.sort (a, b) ->
              if params.order_by
                get_val = (x) ->
                  val = x[params.order_by]
                  val = val?.value || val || ""
                  val = val.toString().toLowerCase()
                a_val = get_val(a)
                b_val = get_val(b)
                if a_val < b_val
                  return -1 * desc
                if a_val > b_val
                  return 1 * desc
              return 0

            index = 0
            for val in stored
              if !val.id?
                continue
              if !match_fn || match_fn(params, val)
                if index >= start && index < start + limit
                  res.push(new OfflineResource(val))
                index++
            @defer(=> success(res)) if success
          else
            @defer(=> error(data)) if error

        if online() && !@synced_recently()
          resource.query(AuthToken.addAuthTokenToJSONRequest(params),
            (data) =>
              for result in data
                if params['short']
                  res.push(new OfflineResource(getData(result)))
                else
                  res.push(@syncObject(result))
              success(res) if success
            , queryLocal)
        else
          queryLocal()

        return res
}]
